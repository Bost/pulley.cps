* What is =pulley=?
  =pulley= is the Positronic utility libraries.
  It is a collection of relatively small, simple libraries
  developed by [[http://www.positronic-solutions.com][Positronic Solutions, LLC]].
  It is our pleasure to make them available to the public.
* What is =pulley.cps=?
  =pulley.cps= is part of the =pulley= collection of libraries.
  It provides a source-to-source compiler for transforming normal Clojure code
  to Clojure code in Continuation Passing Style (CPS),
  as well as runtime support for executing the transformed code.
  Here "normal Clojure code", means code that is /not/ written in CPS.
  It also means that most (but not quite all) code
  that can be compiled by Clojure can be transformed by the CPS compiler.
* Status
  =pulley.cps= is currently very much in the alpha / pre-alpha stage.
  While the features that have been implemented are functional,
  neither the interfaces nor their implementation have undergone
  significant field testing.
  Interfaces are subject to change without notice.
  That being said, interfaces will generally not be changed
  (or will be maintained in a backwards-compatible manner)
  unless there is a significant technical or organizational advantage
  to doing so.
* Features
  =pulley.cps= allows full interaction between CPS and non-CPS code —
  CPS-transformed functions can call regular Clojure functions,
  and vice versa.

  Currently supported features include:
  * application of both "native" and CPS functions
    (i.e., you can call a function regardless of whether
    it is a regular Clojure function or one that has been run through
    the CPS compiler)
  * calls back and forth between native and CPS functions
  * function definitions (you can create a =fn=)
  * special forms: =.= (dot), =def=, =do=, =fn*=, =if=,
    =let*=, =letfn*=, =new=, =quote=, and =var=
  * any and all macros that reduce to transformable code
  * collection literals

  In other words, if there's a reasoable way to transform the code,
  it either is supported or will be in the future.

  =pulley.cps= also provides some features
  that are not normally available in Clojure:
  * Full tail-call optimization (TCO) — all tail calls are done
    in constant space (including =binding= forms).
  * Continuations (with some caveats)
** Planned/Future Features
   Support is being worked on for:
   * exceptions (=throw=, =try=, =catch=, =finally=)

   The following are currently under consideration for future work:
   * Common Lisp-style restarts
   * A way to "escape" transformation
     (for example, to use an unsupported form)
   * Smarter transformation
     (the current compiler uses what Matt Might
     calls the "[[http://matt.might.net/articles/cps-conversion/][naive transformation]]")
   * ClojureScript support
** Unsupported Forms
   It is the general goal of =pulley.cps= to support any and all forms
   that can reasonably be translated to CPS.
   However, there are some forms that are impossible to support directly,
   because they are deeply involved in Java interop.

   For example, forms that define new Java types
   (=deftype=, =definterface=, =genclass=, etc.)
   are difficult to transform in a reasonable manner.
   Even though the method bodies (of, for example, a =deftype=)
   could be transformed,
   invocation of the method would involve the invocation of native code,
   thus defeating the ability to keep the same CPS context.
   It might be possible to work around this,
   but unless and until a suitable solution is developed
   such forms will not be supported.
* Usage
  To use =pulley.cps= in your project,
  simply include the following dependency in your =project.clj=:

  #+BEGIN_SRC clojure
    [com.positronic-solutions/pulley.cps "0.1.0-SNAPSHOT"]
  #+END_SRC

  Note that you will first have to install =pulley.cps=
  to your local Maven repository.

  Now you just need to =require= =pulley.cps=:

  #+BEGIN_SRC clojure
    (require '[pulley.cps :as cps])
  #+END_SRC
** Basic Usage — Invoking the Compiler / Transforming Forms
   The compiler is invoked via two macros:
   * =cps-fn= is used to define a function.
     It's used just like =clojure.core/fn=,
     but the body(ies) of the function will be CPS transformed.
     It returns an =IFn= that executes the CPS code on a trampoline
     if invoked from a non-CPS context.
   * =cps= transforms a sequence of expressions.
     =(cps <body...>)= is equivalent to =((cps-fn [] <body...>))=.
*** Examples
**** Defining a function
     There are a couple options for defining a CPS function.
     The first way is to use =def= and =cps-fn=.
     =cps-fn= is the same as Clojure's =fn=,
     except the function is CPS transformed.

     #+BEGIN_SRC clojure
       (def factorial
         (cps/cps-fn [n]
           (if (> n 0)
             (* n (factorial (dec n)))
             1)))
     #+END_SRC

     You can also use =cps= to wrap the entire definition.
     Then you can use =defn=:

     #+BEGIN_SRC clojure
       (cps/cps (defn factorial [n]
                  (if (> n 0)
                    (* n (factorial (dec n)))
                    1)))
     #+END_SRC
**** Tail Recursion
     The previous example does not use tail recursion.
     While calls to =factorial= will use a constant amount
     of Java stack space, they will still consume heap space
     linearly with respect to =n=.

     If, however, we transform =factorial= to use accumulator passing style,
     we can turn =factorial= into a tail-recursive function.
     Then calls to =factorial= will consume a constant amount of space
     with respect to =n= (ignoring any growth in the size of =acc=).

     #+BEGIN_SRC clojure
       (def factorial
         (cps/cps-fn [n]
           (letfn [(factorial-aps [n acc]
                     (if (> n 0)
                       (factorial-aps (dec n) (* n acc))
                       acc))]
             (factorial-aps n 1))))
     #+END_SRC
**** State Machine
     Of course, Tail Call Optimization (TCO) does not end with simple recursion.
     Another common application of TCO is implementing a state machine.
     Instead of encoding the machine as an explicit loop,
     we encode the machine as a set of mutually-recursive functions.

     For example, suppose we have the following states and transitions:
     | State | Input   | Next-State     |
     |-------+---------+----------------|
     | even  | 0       | odd            |
     | even  | *       | even           |
     | even  | <empty> | <return :even> |
     | odd   | 0       | even           |
     | odd   | *       | odd            |
     | odd   | <empty> | <return :odd>  |
     If =even= is the initial state,
     then this machine will determine whether a given input sequence
     contains an even or odd number of zeroes.

     We can impelement this as:
     #+BEGIN_SRC clojure
       (def even-or-odd-number-of-zeros?
         (cps/cps-fn [inputs]
           (letfn [(even [s]
                     (if (empty? s)
                       :even
                       (let [input (first s)]
                         (if (= input 0)
                           (odd (rest s))
                           (even (rest s))))))
                   (odd [s]
                     (if (empty? s)
                       :odd
                       (let [input (first s)]
                         (if (= input 0)
                           (even (rest s))
                           (odd (rest s))))))]
             (even inputs))))
     #+END_SRC
** Continuations
   =pulley.cps= supports "full" continuations with some caveats:
   * Within a particular CPS context, continuations can be considered
     "full" continuations with respect to that context.
   * However, continuations are implicitly delimited
     by the current CPS context.
     That is, when a continuation is captured,
     the continuation is implicitly delimited
     by the "top-most" transition from non-CPS to CPS code.
   In other words, we try to capture full continuations
   to the extent we are able.
   However, since we can't capture the continuation of non-CPS code,
   the captured continuation can't cross certain boundaries.

   Capturing the current continuation can be accomplished with =call-cc=.
   There's also a macro version, =let-cc=,
   which may be more convenient in some cases.
   They are basically equivalent
   to Scheme's =call/cc= and =let/cc= respectively.
** CPS Overrides
   * =override-fn=
   * =auto-override-fn=
*** Overridden Core Functions
    =pulley.cps= provides CPS overrides
    for the following =clojure.core= functions:
    * =apply=
    * =bound-fn*=
    * =get-thread-bindings=
    * =with-bindings*=
    These functions can be called within a CPS context
    without causing a transition to a non-CPS context per se.
    For example, if =apply= is called with a CPS context
    and is passed a CPS function,
    then that function will be called within the same CPS context.
    On the other hand, if =apply= is passed a non-CPS function then,
    while the call to =apply= itself will be within the same context,
    the actual application of the non-CPS function
    will necessarily cause a transition to a non-CPS context.
** Low-Level Hooks and Interfaces
*** Trampolines, Thunks, and Callables
*** =*special-form-handlers*=
* Contributing
  We sincerely hope you enjoy using =pulley.cps=
  and are able to use it to your advantage.
  If you should find it lacking in some area,
  we hope you will consider contributing in one of the following ways:
  * Reporting bugs — If you think you've found a bug,
    don't hesitate to open an issue on Github.
  * Requesting new features — We won't know what you want unless you tell us.
    If you see we are lacking a feature you would like,
    please feel free to open an issue on Github
    or open a discussion on an appropriate channel.
  * Contributing code — As always, pull requests and patches are welcome.
    However, before investing a large portion of you time
    fixing a bug or implementing a new feature,
    you may wish to drop us a line so we can coordinate our efforts.
